# 核心概念: 两种仿真世界

`core_lib` 提供了两种截然不同的方法来创建和运行仿真，以满足不同需求：一种是模块化的 `SimulationHarness`，另一种是自成一体的 `OntologySimulationAgent`。理解它们的区别对于有效使用本框架至关重要。

## 1. `SimulationHarness`: 模块化系统搭建平台

*   **核心思想**: “自底向上”地构建一个你想要研究或控制的水力系统。
*   **工作方式**:
    1.  用户通过一系列 **YAML 配置文件** (`components.yml`, `topology.yml`, `agents.yml`) 来**声明式**地定义系统的每一个组件、连接关系和智能体。
    2.  `SimulationLoader` 解析这些文件，将它们实例化为 Python 对象。
    3.  `SimulationHarness` 作为“世界引擎”，负责管理所有这些对象，并按时间步驱动整个系统的运行。
*   **用途**:
    *   当你需要**仿真一个特定的、自定义的水力系统**时（例如，模拟你所管辖的某个具体水库大坝和下游河道的交互）。
    *   当你想要研究不同组件或智能体组合在一起时的**涌现行为**时。
*   **一句话总结**: `SimulationHarness` 是一个**通用的、可配置的仿真“沙盘”**，你可以在上面搭建任何你想要的系统。

## 2. `OntologySimulationAgent`: 高保真“虚拟现实”

*   **源代码**: `core_lib/local_agents/ontology_simulation_agent.py`
*   **核心思想**: 提供一个**预先封装好的、高保真的“虚拟物理世界”**，作为其他智能体的测试环境。
*   **工作方式**:
    1.  它本身是一个**单一的、自成一体的智能体**。
    2.  其内部**硬编码**了一套完整的仿真逻辑，包括：
        *   简化的水动力学模型（如过闸流量、水量平衡）。
        *   执行器模型（如闸门移动速度限制）。
        *   传感器模型（如为“真实”水位添加随机噪声）。
        *   扰动脚本（如在特定时间注入旁侧入流）。
    3.  在每个时间步，它独立运行其内部仿真，然后将**模拟的、带有噪声的“传感器”数据**和**模拟的“执行器”状态**发布到消息总线。
*   **用途**:
    *   当你需要**测试一个控制或决策智能体**时。你可以让你的智能体订阅 `OntologySimulationAgent` 发布的数据，并向它发布控制指令，从而在一个可控且可复现的环境中验证你的智能体的性能。
    *   作为其他智能体（如数字孪生、诊断代理）的“陪练”或“数据源”。
*   **一句话总结**: `OntologySimulationAgent` 是一个**用于测试其他智能体的、高保真的“测试桩 (Test Stub)”**。

## 3. 如何选择

*   **“我想搭建一个我们城市供水管网的模型”** -> 使用 **`SimulationHarness`** 和 YAML 配置。
*   **“我想测试我新写的PID闸门控制算法是否有效”** -> 让你的控制算法（封装在`LocalControlAgent`中）与 **`OntologySimulationAgent`** 进行交互。

理解这两种模式是掌握 `core_lib` 仿真哲学的关键第一步。
